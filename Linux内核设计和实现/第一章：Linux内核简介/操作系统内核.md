
* 操作系统构成
    * 系统内核
        * 功能：
            * 中断服务程序
            * 进程调度程序
            * 内存管理程序
            * 进程通信服务程序
    * 系统软件/应用程序：Shell程序/桌面环境GNOME/GNU工具链软件
        * 完成工作的基本行为方式：应用程序通过系统调用界面陷入内核
        * 具体：应用程序通常通过调用库函数调用系统调用，然后让内核代其完成不同的任务。
            * 复杂库函数简单包含系统调用：系统调用只是整个步骤的一部分而已
            e.g. printf()函数实现了数据格式化和缓存，而调用write()系统调用写到控制台只不过是一部分动作而已
            * 库函数和系统调用一对一
            e.g. open()库函数简单调用open()系统调用
            * 库函数不使用系统调用
            e.g. strcpy()库函数

* 系统状态
    * 内核态
        * 程序在内核空间执行
        * 受保护的内存空间
        * 访问硬件设备的所有权限
    * 用户态
        * 应用程序在用户空间执行
        * 只能访问自己的内存空间
        * 使用特点的系统功能和资源
        * 不能直接访问设备


操作系统内核分类
* 单内核:Linux（但是有显著不同和创新）/大多数Unix系统都是单内核的
    * 以单个静态二进制文件的形式存放于磁盘
    * 运行在一个单独的地址空间上：
        * 内核之间通信微不足道，在一个地址空间。
        * 内核可以直接相互调用函数
    * 优点:简单性能高
* 微内核：Windows NT（用于window-xp/win7/window vista)和MacOS（实际上应用中不让任何微内核服务器运行在用户空间，这违背了微内核设计初衷）
    * 被划分为多个独立的过程，每一个过程叫一个服务器
    * **只有强烈请求特权服务的服务器才运行在特权模式下，其他服务器都运行在用户空间**。
    * 所有的服务器都保持独立并运行在各自的地址空间上
        * 不能直接调用函数，而是需要通过IPC机制
    * 优点：
        * 有效避免一个服务错误影响另外一个服务
        * 模块化的系统允许一个服务为了另外一个服务换出
    * 缺点：IPC开销大，周期长
    IPC机制的开销多于函数调用，又涉及内核空间与用户空间的上下文切换，存在一定周期
* 外内核

Linux内核和Unix对比：
* Linux是单内核，吸取了微内核的精华｜Unix是纯粹单内核
* 模块化内核
* 抢占式内核： 允许在内核运行任务优先执行的能力｜大多数Unix内核不支持抢占
* 支持内核线程： 内核并不区分线程和其它的一般进程
* 动态装载内核模块的能力：允许在需要的时候动态地卸除和加载部分内核代码｜一般的Unix无法卸载内核代码
* 支持对称多处理SMP机制｜传统的Unix不支持这种机制。
* Linux忽略了一些被认为是设计得很拙劣的Unix特性 e.g. STREAMS
* Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统(sysfs)

