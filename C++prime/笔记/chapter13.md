# 拷贝控制

* 拷贝操作：定义用同类型对象初始化对象的操作
    * 拷贝构造函数
    * 移动构造函数
* 赋值操作：定义将一个对象赋予同类型对象时候的操作
    * 拷贝赋值函数
    * 移动赋值函数
* 销毁操作：定义此类型对象销毁时候的操作
    * 析构函数

* 我们是否应该手动定义这些操作？
    * 对于简单类，不涉及动态分配的类，可以由编译器生成
    * 对于复杂类，最好自己手动定义，依赖默认定义会导致灾难




## 拷贝赋值销毁

### 拷贝构造函数

* 编译器合成原则：只有我们没有定义拷贝构造，就会替我们合成，即使我们定义了其他构造函数
* 合成拷贝构造函数
    * 对于类类型成员，使用其拷贝构造函数进行拷贝
    * 对于内置成员，直接拷贝
* 拷贝构造函数形式
    * 参数为自身类型的引用：不是引用的话会无限调用拷贝构造函数
    * 参数几乎总是一个const
    * 没有返回值
* 拷贝初始化：
    * 方式：使用拷贝构造函数/移动构造函数
    * 时间：
        * =定义变量
        * 对象作为实参传递给非引用的形参
        * 从一个非引用返回类型返回对象
        * 初始化标准库容器或对其插入元素
        * 花括号列表初始化一个数组中的元素或一个聚合类中的成员？？？
    * 限制：如果拷贝构造函数时一个explicit函数，那么不能通过它进行类型转换
        * 在初始化过程中如果需要先进行类型转换，那么就无法直接拷贝初始化，直接初始化比较好

### 拷贝赋值
* 重载赋值运算符
    * 定义为类的成员函数
    * 左侧对象绑定到隐式的this指针，返回指向其左侧对象的引用
    * 右侧运算对象为显式参数传递，参数不要求为引用
        * 可以传引用，也可以是传值
        * 可以是const，也可以是非const
* 编译器合成原则：只有我们没有定义拷贝赋值运算符，就会替我们合成拷贝赋值运算符

### 析构函数
* 析构函数
    * 不接受参数，不能重载
    * 因此，对于给定的类，只有一个析构函数
* 析构函数工作：析构函数体是作为成员销毀步骤之外的另一部分进行的
    * 函数体部分：先执行函数体
    * 析构部分：再按成员初始化的顺序逆序销毁成员
        * 类类型成员执行自己的析构函数
        * 内置成员类型没有析构函数，不用操作
* 什么时候调用析构函数：无论何时对象被销毁时
    1. 变量离开其作用域
    2. 动态分配的东西调用delete
    3. 临时对象创建它的完整表达式结束时？？？
    4. 容器被销毁，其中元素被销毁
    5. 对象被销毁，其成员被销毁

* 编译器合成原则：当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数

### 移动构造
* 移动构造函数的形式
    * 第一个参数类型是该类类型的右值引用
    * 第一个参数一般是非const，因为需要确保移后源对象可析构，需要修改它的值。
    * 如果存在其他参数，那么必须要有默认实参



### 移动赋值
* 指向移动构造函数和析构函数的工作
* 需要noexcept说明符
* 同样需要处理自赋值的情况

#### 移动操作的要点
1. 对移动操作设置异常说明符noexcept
    1. Question:为什么移动操作一般不抛出异常？
    Answer:因为移动操作通常不进行内存的分配
    2. Question：为什么要使用noexcept通知标准库移动操作不抛出异常
    Answer:如果不显式告诉它，它认为移动类对象可能抛出异常，为了处理这种可能要做额外的工作开销
    3. Quesition:移动操作带来的潜在的异常会导致什么问题？
    Answer:vector保证，如果调用push_back发生异常，可以保证vector不变。但是如果使用移动操作，移动后移后源的元素会发生改变，发生异常的话，导致无法恢复原来的vector。所以为了应对这种异常，vector在重新分配内存的过程中使用拷贝构造函数，而不是移动构造函数。而使用拷贝构造比移动构造函数开销大，需要不断构造和析构对象。通过添加noexcept说明符，可以告诉容器：移动构造函数是安全的不会发生异常可以安全使用。那么容器就会在重新分配内存的时候使用移动构造函数。
    4. Question:noexcept说明符放哪里？
    Answer:函数列表和初始化列表开始的冒号之间

2. 移动操作要完成的目标：确保移后源对象的销毁是无害的。一旦资源完成移动，源对象不再指向被移动的资源，资源的所有权归属新对象。e.g. [StrVec(StrVec &&s) noexcept](../代码/chapter13/copy-control/StrVec.hpp)

3. 移动操作的不合成原则：如果定义了拷贝控制成员（拷贝构造/拷贝赋值/析构），编译器就不会合成移动操作
4. 移动操作的合成原则
    * 没有定义任何的拷贝控制成员
    * 所有的非static成员都是可以移动的
        * 内置类型默认可移动
        * 类类型必须要有对应的移动操作

5. 合成的移动操作被定义成删除的情况：
    1. =default要求编译器合成，但是无法移动某些成员，导致合成的移动操作为删除
    2. 类成员没有移动操作，编译器不会为类合成移动操作
        * 定义了拷贝构造成员但是没有定义移动构造
        * 类成员未定义拷贝构造函数，但是编译器无法替他合成移动构造函数
    3. 类成员的移动操作被定义为删除或者不可访问，那么类移动操作被定义为删除
    4. 析构函数被定义为删除或者不可访问，那么移动构造函数定义为删除
    5. 类成员是const或者引用，移动赋值运算符被定义为删除

6. 右值被移动，左值被拷贝
7. 如果没有移动构造函数，即使传递右值，还是会调用拷贝构造函数
8. 移动迭代器：解引用返回右值引用
    * 标准库`make_move_interator`函数将普通迭代器转换成移动迭代器

### 三五法制
三个基本操作可以控制类的拷贝操作
* 拷贝构造
* 拷贝赋值
* 析构函数

* 注意：通常只需要手动定义其中一个，而不需要定义所有三个操作的情况是极少的。我们一般把它们当作一个整体

* **三/五法则**
    1. 需要定义析构函数的通常也需要定义拷贝构造和拷贝赋值
        * 理由：
            1. 当我们在类中动态分配了内存，合成的析构函数不会delete指针，此时我们需要手动定义析构函数
            2. 如果使用合成的拷贝构造拷贝赋值操作只会简单复制指针的值
            3. 多个对象可能包含相同的指针，指向同一块内存，释放时造成多次析构delete同一块内存
    2. 如果一个类需要拷贝构造函数，那么可以肯定赋值运算符；如果需要赋值运算符，那么肯定需要拷贝构造函数
        * 理由：
            1. 如果需要手动定义拷贝构造函数，那么新的对象和旧的对象肯定不能完全简单复制
            2. 既然不能完全简单复制，那么拷贝赋值运算符也必须手动重新定义
    3. 一个类如果定义了任何一个拷贝操作，那么应该定义所有5个操作
        * 理由：某些类动态分配资源，必须定义拷贝控制成员，这个时候定义移动构造函数可以避免额外的开销


### =default
* 只能对具有合成版本的成员函数使用：让编译器显式帮我们合成
    * 默认构造函数
    * 拷贝控制成员

### 阻止拷贝：定义某种机制阻止类对象拷贝或者赋值
* 为什么有阻止拷贝的需求？
* 如iostream类阻止拷贝，避免多个对象同时读入或者写入相同的缓冲

* 那么直接不定义拷贝控制成员？
* 不行！不定于编译器只会帮你合成拷贝控制成员

* =delete｜=default
    * 必须出现在第一次声明的地方｜可以出现在类外定义处
    * 我们可以对任意函数使用=delete｜只能对拷贝控制成员和默认构造函数使用

* 析构函数不能是删除的=delete
    * 析构函数被删除，我们就无法删除销毁该对象。对于无法销毁的对象，就不应该创建
    * 一个类的成员的析构函数被删除，也不能定义该类型的对象。因为成员无法销毁，那么对象也无法销毁。

* 但是合成的拷贝控制成员可能是删除的：你自己不定义拷贝控制成员，编译器帮你合成，但是可能会是删除的，因此不可调用
    1. 成员的拷贝构造函数是删除的或者不可访问的，那么合成拷贝构造函数会是删除的
    2. 成员的析构函数是删除的或者不可访问的
        * 类的合成析构函数会是删除的：成员不可删除，那么类更不可能删除
        * 类的合成拷贝构造函数是删除的：无法析构就无法构建
        * 类的默认构造函数被定义为删除：无法析构就无法构建
    3. 类成员的拷贝赋值运算符删除或者不可访问，类合成的拷贝赋值运算符会是删除的
    4. 类中有const成员或者引用成员，类合成的拷贝赋值运算符会是删除的
        * const成员不能解绑定
        * 引用成员也不能解绑定
    5. 具有引用成员或者无法默认构造的const成员，编译器合成的默认构造函数定义为删除
        * 引用成员必须绑定,合成的默认构造无法给它绑定
        * const成员也必须绑定，合成的默认构造无法给它绑定
    6. 类定义了移动构造和移动赋值，该类合成的拷贝构造和拷贝赋值会被定义为删除。



## 具有类外资源的类的拷贝控制定义

* 具有类外资源的类必须定义拷贝控制成员
    * 需要通过析构函数释放对象分配的资源--》需要析构函数
    * 既然需要析构函数，那么也需要拷贝构造函数和拷贝赋值运算符---》需要拷贝构造函数和拷贝赋值运算符
结论：具有类外资源的类需要自定义拷贝构造/拷贝赋值运算符/析构函数

* 考虑拷贝控制语义：应该如何定义拷贝控制
    * 类行为像值的拷贝：有自己独立的状态，副本和原对象不互相干扰：string对象和标准库容器
    * 类行为像指针的拷贝：副本和原对象使用相同的底层数据，改变副本会改变原对象：shared_ptr
    * 类行为既不像值也不像指针：IO类/unique_ptr类不可拷贝赋值

* [定义行为像值的类](../代码/chapter13/HasPtr_Like_Value.hpp)
* [定义行为像指针的类](../代码/chapter13/HasPtr_Like_Point.hpp)
    * 通常使用shared_ptr来管理类中动态分配的资源
    * 但是我们这里希望能够直接管理资源，使用动态内存分配的计数变量


## 交换操作
* 定义swap操作
    * 如果我们调用swap交换对象，如果类对象没有定义自己的swap函数，那么就会调用std::swap,但是结果并不一定符合我们的期望：因为类成员可能有自己的swap函数，对类对象调用std::swap那么也会对类成员调用std::swap，结果可能出错。
    * **best practice**:添加using std::swap是个好习惯，调用swap函数应该是未加限定的
        * 如果存在特定类型的swap，它的匹配程度高于std::swap：因为对于可行匹配，非模版函数比模版函数优先级更高，而std::swap是模版函数。因此即使声明了using std::swap，还是会选择特定类型的swap而不是标准库swap。
        * 如果不存在特定类型的swap，有了using std::swap,就会调用std::swap, 如果没有using std::swap，还去调用swap那就会出错


* 使用swap操作：我们可以使用swap实现拷贝赋值运算符
    ```c++
    HasPtr& HasPtr::operator=(HasPtr p)
    {
        swap(*this,p);
        return *this;
    }
    ```
    * 参数不是一个引用，因此p是右侧运算对象的副本
        * 右侧对象以传值方式进行拷贝构造形参变量p，得到右侧运算对象副本
        * swap调用之后，*this的指针成员指向新分配的string--右侧运算对象的副本
        * swap结束时，p被销毁，HasPtr析构函数被调用，释放左侧运算对象交换前的内存
    * 能够处理自赋值情况并且是异常安全的


## [需要拷贝控制的原因之一：薄记工作](../代码/chapter13/copy-control/Message.hpp)
## [需要拷贝控制的原因之二：动态内存管理](../代码/chapter13/copy-control/StrVec.hpp)


### 右值引用
引用
: 某个对象的另外的名字
右值引用&&
: 必须绑定到右值的引用

* 重要性质：只能绑定到即将销毁的对象
* 功能：自由地将右值引用的资源移动到另外一个对象

* **右值**
    * 右值引用：不能绑定到左值，能绑定到字面常量/返回右值的表达式等右值表达式
    * 返回右值引用的函数：算术/关系/位/后置递增递减运算符/
    * 右值短暂：要么是**字面值常量**，要么是表达式求值过程中创建的临时量
        * 所引用对象快要被销毁了
        * 该对象没有其他用户
    * 结论：右值引用的代码可以自由接管引用对象的资源,因为右值引用接近被销毁，可以窃取对象状态

* **左值**
    * 左值引用：与右值引用相反，不能绑定到右值。
    * 返回左值引用的函数：赋值/下标/解引用/前置递增递减/复合赋值运算符
    * 左值有持久的状态

* 不能直接将右值引用绑定到一个左值上，但是存在方法：
    * 显式将左值转换为对应的右值引用类型 static_cast<>
    * 标准库move函数模版：其内层也是依靠static_cast<>实现

* 使用std::move的情况：如果对一个变量，你希望像右值一样处理它，那么就可以通过使用std::move返回它的右值引用。
    * 条件
        * 保证移动后该对象处于可安全析构：可以被安全销毁
        * 保证移动后该对象处于有效的状态：
            * 你可以重新给它赋值后再使用它
            * 直接使用它的话状态不定，不能依赖于它的值


