# 为类重载运算符和进行类类型之间的类型转换
## 为类类型重载运算符

### 基本概念
* 重载的目的是：让能够在内置类型上的运算符也能在类类型上使用，且用法和作用相似。
    * 因此：对于一个重载的运算符函数，它要么是类的成员，要么至少含有一个类类型的参数。才必须与类相关
* 重载运算符是一种特殊的函数
* 重载运算符函数构成
    * 关键字operator
    * 需要定义的运算符号+、-、*、/等
    * 返回类型
    * 参数列表
    * 函数体

* Question：重载的运算符函数可以有默认实参数吗？？？
* Answer：除了重载的函数调用运算符operator()外，其他不可以。
e.g. 如果可以用，那么对于重载的加号+运算符。可以这样调用`a+`和` +b`甚至是`+`。显然是不符合我们对+的使用印象的

* 重载的运算符函数可以是成员函数，也可以是非成员函数
    * 非成员函数
        * 参数数量和运算符作用的运算对象一样多
        e.g. 对于二元运算符，则有2个参数。左侧运算对象传递给第一个参数，右侧运算符传递给第二个参数
        * 调用方法
            * 直接调用`operator+(data1, data2);`像调用普通函数一样
            * 间接调用`data1 + data2;`想在内置类型上使用+一样
        * 如果这个时候它必须访问类的非public数据成员，必须把它定义成类的友元函数
    * 成员函数
        * 参数数量要比运算符的运算符对象少一个
        * 左侧运算对象绑定到this指针，右侧运算对象传递给函数参数
        * 调用方法
            * 直接调用`data1.operator+=(data2);`像调用成员运算符一样
            * 间接调用`data1 += data2;`像表达式一样直接使用符号

* 重载运算符的原则
    2. 我们可以重载大多数运算符，但是并不是全部
        * 有些运算符一定不能被重载的
            * `::`作用域运算符，只能作用于类名，不能作用于内置类型
            * `? :`/`.`/`.*`
        * 有些运算符不应该被重载：可以重载，但是跟习惯求值规则不同
            * 逗号运算符：从左到右顺序求值，但是重载运算符的调用相当于函数调用，参数求值没有顺序可言
            e.g. `i = (j++, j+100, 999+j);`
            * 逻辑&&和逻辑||：具有短路特性，左边参数为一旦确定为false(&&)或者true(||)，那么就不对右边进行求值。但是重载运算符所有参数都一定会被求值
            e.g. `i&&j`
            * ~~去地址&运算符~~：已经在类对象中有了特殊含义（对类对象取得地址）被重载的话行为比较奇怪
    3. 我们只能重载已经有的运算符，而无权发明新的运算符：在内置类型上没有的运算符号，在类类型上不应该有
    4. 重载运算符在类上的使用 应该尽可能保持和其**在内置类型上使用**相同的使用特性
        * 如果该类执行IO操作，则应该重载移位运算符<</>>让IO操作和在内置类型上的IO操作保持一致
        * 如果类对象有检查相等性的操作，应该重载operator== 如果重载了operator== 那么通常应该重载operator!=
        * 如果类对象包含单序比较操作，则应该重载operator< 如果重载了operator<  那么通常也应该重载operator>
        * 重载运算符的返回类型应该和内置版本的返回类型相同
            * 逻辑和关系运算符重载返回bool类型
            * 算术运算符应该返回类类型
            * 赋值运算符和复合赋值应该返回左值运算对象的引用
        * 如果有重载算术运算符+、-、*、/、｜、^、&等，也应该重载它们的复合赋值运算符+=、-=、*=、/=等
    5. 确定重载的运算符函数应该作为成员函数还是非成员函数
        1. 具有对称性的运算符（运算符定义的形参类型相同）通常应该是非成员函数：算术/相等性/位运算/关系运算
            * 两个运算对象类型相同时是理想的状况
            * 不理想的状况：两个运算对象类型不同，涉及混合类型运算。
                * 如果我们把它作为成员函数，两种类型都会可能是左侧运算对象。那么两种类型都必须同时重载该运算符函数->很麻烦
                * 如果是非成员函数，那么只要做好从实参到形参的类型转换即可，处理方式类似内置类型的加法e.g.`int a;double b;a + b`
                    * **只有作为非成员函数**才能应对非理性状态下的混合类型计算
                    * 当然这有要求：
                        1. 至少有一个运算对象是类类型，不然函数无法匹配
                        2. 并且另外一个对象必须能转换(无法转换则出错)
        2. 输入输出运算符必须是非成员函数
            * 假设输入输出运算符函数是我们要**正在定义类**的成员函数,那么应该这样使用：`data<<cout`。显然这不符合在内置类型上的使用习惯
            * 如果要符合使用习惯，那么应当这样：`cout<<data;`,那么输入输出运算符函数是在<istream>和<ostream>中类的成员函数。然而我们无法给标准库添加成员。
            * 综上所述得结论：输入输出运算符函数必须是非成员函数。如果要读写类对象的非公有数据成员，还应该定义类内友元声明。
        2. 赋值`=`、下标`[]`、函数调用`()`、成员访问箭头`->`重载运算符函数必须是成员函数
        3. 递增递降解引用通常应该是成员函数：建议作为成员函数重载！！！
        4. 复合赋值运算符一般来说是成员函数:虽然不非得是成员函数，为了保持和赋值`=`一致，习惯定义为成员函数！！

### 输入输出运算符重载
* 重载输入运算符>>
    * 第一个参数`istream &is`
        * 非常量的原因：从流中读取内容改变流的状态
        * 引用的原因：流对象无法拷贝
    * 第二个参数`Sales data &item`
        * 非常量的原因：需要给item写入数据
        * 引用的原因：避免拷贝
* 重载输出运算符<<
    * 第一个参数`ostream &os`
        * 非常量的原因：我们要向流写入内容会改变其状态
        * 引用的原因：因为流对象无法复制
    * 第二个参数`const Sales data &item`
        * 常量的原因：我们用打印输出，不会改变它的内容
        * 引用：避免复制实参
    * 输出运算符应该尽可能少地减少格式化操作，让用户控制输出打印类对象的细节--->让打印输出功能原子化

### 算术和关系运算符
* 算术运算符
    * 通常应该是非成员函数
    * 一般不允许改变运算符对象的值，所以形参是常量的引用
    * 计算两个运算对象，得到新值放入局部变量中，返回该局部变量的副本
    * 通常情况下，应该使用复合赋值运算符实现算术运算符
* 相等运算符
    * 通常应该定义成非成员函数
    * 如果定义了operator==运算符，则类可以判断一组给定对象中是否有重复的数据
    * 相等具有传递下，如果a == b, b == c,那么a == c
    * 如果定义了operator==运算符,也应该定义operator!=运算符
    * operator==和operator!=一个负责实际的工作，另一个把工作委托给对方

* 关系运算符
    * 如果某类型定义了行为正常的<运算符，那么该类型可以作为有序容器的关键字类型
    * 如果存在唯一逻辑可靠的<定义，则考虑为这个类定义<运算符
    * 如果类同时包含==运算符，当前仅当<和==结果一致时才定义<运算符

### 赋值运算符
* 赋值运算符：不同于拷贝赋值函数，我们可以使用别的类型作为右侧运算对象来重载赋值运算符，而不是本类的对象
    * 必须是成员函数：
        * 如果类中没有定义拷贝赋值函数，那么编译器会合成拷贝赋值运算符。
        * 如果把重载的赋值运算符写成友元函数，那么参数列表（2个参数）就和合成的拷贝赋值函数（1个参数）不一样，不能发生重载。
        * 因此：无论参数类型是什么，我们都必须将其写为成员函数进行**赋值运算符重载**。
    * 必须先释放当前空间，在申请新的空间
    * 通常返回指向其左侧对象的引用

* 复合赋值运算符
    * 返回左侧运算对象的引用
    * 不是非得是成员函数


### 下标运算符
* 重载的下标运算符用于容器中通过元素的位置访问元素
    * 必须是成员函数
    * 以访问元素的引用作为返回值：可以出现在赋值运算符=任意一端
    * 通常同时定义常量版本和非常量版本，作用于常量对象

### 成员访问运算符

* 解引用运算符*
    * 通常是类的成员函数

* 箭头运算->？？？？
    * 必须是成员函数
    * 通常不进行操作，而是调用解引用操作，返回解引用操作的结果元素的地址


### 函数调用运算符
* 必须是成员函数
* 对象调用看上去是函数调用，实际上在运行对象的重载的函数调用符
* 一个类可以定义多个不同版本的调用运算符，相互之间在参数数量和类别上有区别
* 函数对象：定义了调用运算符的类的对象

#### lambda是函数对象
* 当我们编写一个lambda表达式，编译器将它翻译成未命名类
    * 重载了调用运算符函数
        * 默认情况下，lambda产生的类中重载的调用运算符函数是const成员函数，不可以改变数据成员的值（该数据成员根据捕获变量创建）
        * 如果lambda声明为mutable，则该调用运算符就不是const，可以改变捕获的变量
    * 不含有默认构造函数
    * 不含有赋值运算符
    * 不含有默认析构函数
    * 如果有值捕获，那么会有相应的构造函数
    * 是否有默认的拷贝/移动构造函数要视捕获的数据类型而定
* 在函数中使用lambda表达式时，相当于向函数传入一个该未命名类的未命名对象

* lambda捕获方式
    * 值捕获
        * 产生的类为捕获的变量建立对应的数据成员，同时构建构造函数，用捕获的值初始化该数据成员
    * 引用捕获
        * 由程序确保引用的对象存在，确保引用的局部变量还在作用域内，编译器可以直接使用引用。


#### 标准库定义的函数对象
* `plus<int> intAdd;可对int做加法的函数对象`
* `plus<string> stringAdd;可对string做加法的函数对象`

#### 可调用对象的funtion

* 不同的可调用对象：无论是函数/函数指针/lambda表达式/重载了调用运算符的类/bind创建的对象
* 调用形式：指明了调用返回的类型，以及传递给调用的实参类型
* 不同的可调用对象可以共享同一种调用形式
* 标准库function类型functin<T> f
    * f是存储可调用对象的空function
    * 可调用对象的调用形式与T相同
    * 可以把相同调用形式但是却是不同可调用对象传递给f

### 递增递减运算符
* C++语言并不要去递增递减运算符作为成员函数，但是改变的正好是所操作对象的状态，所以建议作为成员函数重载
* 内置类型有前置/后置版本，为了重载类的运算符，那么应该定义前置后置版本
    * 前置版本
        * 返回递增递减后对象的引用
        * 显式调用：`p.operator++();`
    * 后置版本
        * 返回一个值而非引用
        * 重载后置版本带有int形参
        * 显式调用：`p.operator++(0);`

## 类类型的类型转换

* 用户定义的类型转换
    * 转换构造函数：将实参类型的对象转换成类类型
    * 定义类型转换运算符：将类类型转换成其他类型

* 类型转换运算符`operator type() const;`
    * 是一种类的特殊成员函数：负责将类类型的值转换成其他类型
    * 能够转换的类型
        * 能对除了void之外任意类型进行转换，只要该类型可以作为普通函数的返回类型，因此不能转换成数组或者函数类型，但是允许转换成指针（数组指针/函数指针）或者引用类型
    * 结构
        * 没有返回类型:虽然不指定返回的类型，但是每个类型转换运算符会返回一个对应类型的值，值类型和目标的转换类型不匹配会出错 `operator int*() const { return 42; }// 错误：目标转换类型为指针，42不是一个指针，不匹配`
        * 没有形参
        * 必须定义成类的成员函数
        * 带有const：通常不应该改变待转换对象的内容
        * 可以隐式转换，也可以显示转换：为了避免意外的结果，可以将类型转换定义成explicit
        ```C++
        operator int() const
        {
            return this->hours * 60 + this->minuts;
        }
        // 不能隐式转换
        explicit operator float() const
        {
            return float(this->hours * 60 + this->minuts);
        }
        MyTime t1(1,20);
        int minutes = t1;// 隐式转换
        float minutes = float(t1) // 显式转换
        float minutes = static_cast<float>(t1) // 显式转换
        ```
        * 但是存在例外：即使将转换运算符函数定义成explicit，如果它被用做条件，显式的类型转换还是会被隐式执行


* 定义转换运算符
```C++
class SmallInt{
public:
    // 定义了从int向类类型的转换
    SmallInt(int i = 0):val(i)
    {
        if(i < 0||i > 255)
            throw out_of_rang("Bad SmallInt Value");
    }
    // 将smallInt转成int
    operator int() const
    {
        return val;
    }
private:
    std::size_t val;
};
SmallInt si;
si = 4;// 将4隐式转换成smallInt
si + 3;// 将si隐式转换成int
```
* 注意点：尽管编译器一次只能执行一个用户定义的类型转换，即一次进行一步转换，不能一次转两步。但是隐式的用户定义的类型转换可以和内置类型转换一起使用
```C++
// 内置类型先将double 3.14 转成int 3
// 再调用SmallInt(int)构造函数将int转成SmallInt类型
SmallInt si = 3.14;
// SmallInt类型转换运算符将si转换成int
// 内置类型转换再将int转成double类型
si + 3.14;
```

### 避免二义性的类型转换
* 如果一个类中有多个类型转换运算符，必须确保类类型和目标类型只有一种唯一的转换方式，只调用其中一种转换运算符。
否则，我们的代码具有二义性，编译器不知道我们要调用哪个转换运算符。

* 类型转换
    * 用户定义的类型转换：转换构造函数/转换运算符函数
    * 标准类型转换 int->double/int->bool
* 存在二义性的情况：存在多重转换路径
    1. A类定义了接受B对象的转换构造函数，B类定义了转换目标是A的转换运算符。
        * 两种方式都是B——>A相同类型转换.
        * 即使是static_cast显式强制类型转换也无法解决二义性问题
    ```C++
    struct B;
    struct A
    {
        A() = default;
        A(const B&); // 把B转换A
    }；
    struct B
    {
        operator A() const; // 把B转向A
    }
    A f(const A&); // 定义了一个接受A的函数
    B b;
    A a = f(b); // 括号内应该执行f(B::operator A()) 还是f(A::A(const &B))
    ```
    2. 类定义了多种转换规则，转换函数之前或之后存在标准类型转换，则标准类型级别将决定最佳匹配到底是哪个
        1. 如果涉及的标准类型转换级别相同，将产生二义性。
        ```C++
        struct A
        { 
            // 创建了2个转换源都是算术类型的构造函数
            A(int a = 0);
            A(double);
            // 创建了2个转换目标都是算术类型的构造函数
            operator int() const;
            operator double() const;
        }
        void f2(long double);
        A a; 
        // A a的转换目标int和double通过long double联系在一起
        // 转换目标是内置类型
        f2(a);// 是执行operator int()还是operator double()呢？二个自定义的类型转换符号级别相同，二者都不比对方好。后续int->long double和double->long double标准类型转换也相同。无法产生最佳匹配，从而产生二义性
        long lg;
        // A a2的转换源int和double通过long联系在一起
        A a2(lg);// 两个构造函数都无法精确匹配long类型，long->int和long->double的标准类型转换级别相同，用户定义的类型转换A(int)和A(double)转换级别也相同。无法产生最佳匹配，从而产生二义性
        ```
        2. 如果标准转换级别不相同，那么标准类型转换的级别将决定编译器选择最佳匹配，不会产生二义性
        ```C++
        short s = 42;
        A a3(s);// short->int比short->double的标准类型转换级别更高，因此产生了更精确的匹配。使用A::A(int)
        ```
    3. 重载函数与转换构造函数:当我们调用重载的函数时,从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换构造函数都提供了同一种重载函数的匹配，则这些类型转换一样好，因此调用出现二义性。
    ```C++
    struct C
    {
        C(int);
    };
    struct D
    {
        D(int);
    };
    void manip(const C&);
    void manip(const D&);
    manip(10); // 二义性错误：应该调用manip(C(10))还是manip(D(10))
    ```
    4. 函数重载和用户定义的类型转换:当调用重载函数时，如果多个用户定义的类型转换都提供了可行的匹配，则多个匹配一样好（**即使其中一个定义的类型转换需要事先进行标准类型转换**）**这个时候我们不考虑出现的标准类型转换**，仍然将它们视为同等效力的转换，进而导致代码出现二义性，编译器会表示标识错误。
    ```C++
    struct C
    {
        C(int);
    };
    struct E
    {
        E(double);
    };
    void manip2(const C&);
    void manip2(const E&);
    manip2(10);//  编译器是选择manip2(C(10)) 还是manip2(E(double(10)))
    // manip2(const C&)可行，因为类C提供了C(int)的构造函数，该构造函数和实参精确匹配
    // manip2(const E&)可行，因为类E提供了E(double)的构造函数，该构造函数需要事先利用标准类型转换将int转成double
    // 虽然manip2(const E&)需要多一步标准类型转换，但是相比用户自定义的转换类别，标准类型转换被编译器视为优先级更高，在编译时进行自动进行无需干预，因此可以被忽视，对匹配的影响因此忽略。所以多个用户定义的类型转换仍然具有二义性错误。
    ```
### 函数匹配和重载的运算符

* 普通的函数调用/命名函数的调用：可以清楚的分辩调用的是成员函数还是非成员函数，该名字的成员函数和非成员函数不会重载
* 原因：调用成员函数的语法`a.operatorsym(b)`和调用非成员函数`operatorsym(a, b)`的语法不同

* 表达式调用候选函数集合更大
* 例如：如果a是一个类对象，则表达式a sym b可能调用
    * `a.operatorsym(b)`
    * `operatorsym(a, b)`

* 重载的运算符通过表达式作用于类对象时 e.g. `SmallInt s3 = s1 + s2;`
    * 候选函数集为
        * 运算符的普通非成员版本
        * 运算符的内置版本（虽然在候选函数集中，但是在匹配过程中淘汰）
        * 运算符函数的成员版本
    * 注意：如果该类提供了转换目标是算术类型的类型转换，并且执行混合类型的算术计算，表达式对于使用重载的运算符还是内置运算符会存在二义性
    ```C++
    class SmallInt{
        friend operator+(const SmallInt&,const SmallInt&);
    public:
        operator+(const SmallInt&);
        SmallInt(int=0);
        operator int() const{  return val; }
    private:
        std::size_t val;
    };
    SmallInt s1,s2;
    SmallInt s3 = s1 + s2;
    // 可以把0转换成SmallInt,然后使用SmallInt的加法
    // 或者把SmallInt转换成int，然后使用内置加法
    // 存在二义性错误
    int i = s3 + 0;
    ```
