
## 定制操作

* 为什么要定制操作？那sort函数举例子：默认使用元素类型的<运算符进行比较
* 原因
    * 我们希望的排序与<定义的不同
    * 序列中保存的元素类型未定义<运算符
* 因此综上：我们需要重载sort的默认行为，定制其操作

谓词：可调用的表达式，返回结果是一个可做条件的值
* 一元谓词：接受单一参数
* 二元谓词：接受2个参数

**可调用：如果一个对象或者一个表达式，可以对其使用调用运算符，那么即为可调用**
* 可调用对象：
    * 函数/函数指针
    * 重载了调用运算符的类对象
    * lambda表达式（实际上就是重载了调用运算符的类对象）

* lambda表达式（没有名字）
    * 捕获列表（不可省略）
    * 参数
        * 没有默认实参
        * 实参和形参类型必须匹配
        * 实参数量必须和形参数量相等
    * 返回类型:
        * 使用尾置返回
        * 没有的话会从函数体代码推断
            * 只有return语句，则根据return类型判断
            * 有return语句，并且包含return之外的其他语句如if，则为返回void
            e.g. 下面的代码尽管包含return i的语句，编译器推断结果返回类型是void。
            ```C++
            transform(vi.begin(),vi.end(),vi.begin(),
            [](int i){if (i < 0) return -i;else return i;});
            ```
            这个时候如果想返回int，应该指定返回类型int。
            ```C++
            transform(vi.begin(),vi.end(),vi.begin(),
            [](int i)->int
            {if (i < 0) return -i;else return i;});
            ```
    * 函数体（不可省略）
* 定义lambda对象
```C++
auto f = []{return 42}
cout << f() << endl;
```

* 使用捕获列表：通过将局部非static变量包含进来，能够在lambda函数体中使用
    * 显式捕获：通过明确指明确定使用的局部变量
        * 值捕获：lambda创建时拷贝捕获变量的值
        * 引用捕获：在lambda中使用引用时，实际使用的是引用绑定的局部变量
    * 隐式捕获：编译器根据lambda体中代码推断捕获列表
        * &告诉编译器采用引用捕获
        * =告诉编译器采用值捕获
    * 混合显式隐式捕获
        * 捕获列表第一个元素是&或者=，指定默认捕获方式
        * 捕获列表后面的元素明确指明要捕获的局部变量

* lambda可以直接使用static局部变量和所在函数之外声明的名字
* 我们通常向函数传递lambda对象，我们也能从函数返回一个lambda对象
    * 此时不能包含引用捕获，因为出了函数，局部变量不存在，引用捕获失效

* 可变lambda
    * 默认情况下，lambda不能改变值捕获的变量的值
    * 如果希望能改变被值捕获的变量，使用mutable关键字
    ```C++
    void fcn3()
    {
        size_t v1 = 42;
        auto f = [v1]() mutable { return ++v1;};// 捕获了v1，用v1的值初始化lambda表达式生成的类中的数据成员
        v1 = 0;
        auto j = f();// j = 43
    }
    ```