# 类

## 类的声明
* 可以类的声明和定义分开——前向声明
* 前向声明的类是一种不完全类型
* 使用场景有限
    1. 定义指向这种类型的指针和引用
        * 因为不论指向何种类型，指针变量的大小固定，因为其保存的是地址。
        * 引用是底层实现也是指针，同上理解
    2. 声明不完全类型作为参数或返回类型的函数
* 不能使用的场景
    1. 创建类对象：因为创建对象需要知道需要的内存大小，类必须被定义过
    2. 访问类成员：没有类定义，不知道有哪些类成员
* 注意：**一旦一个类名出现后，就相当于声明过了**，因此类允许包含指向自身类型的指针或者引用
```C++
class Link_Screen{
    Screen window;
    Link_Screen *prev;
    Link_Screen *next;
};
```
## 定义抽象数据类型

### 定义类的成员函数
* 定义类的成员函数
    * 在类外定义
        * 在类内必须声明
        * 类外的定义和类内的声明必须一致,包括const属性
        * 必须有所属的类名和类作用域运算符
    * 在类内定义：在类作用域内

* 成员函数this指针：是成员函数的隐式参数，用来访问调用成员函数的对象
    * 当对象total调用成员函数时，编译器把total的地址传递给this指针
    * 成员函数内任何自定义this参数或者变量为非法
    * this是一个常量指针，不能改变this中保持的对象地址。

* 返回*this指针的成员函数
    * 返回左值引用的函数返回*this
    * 如果成员函数是const，那么将返回const引用（常量引用）

* 成员函数的const属性
    * 不带const属性的成员函数：非常量成员函数
        * this指针是指向普通对象的常量指针`Sales_data *const ptr`。
        * 只能被非常量对象调用
        * 可以改变对象的内容
    * 带有const属性成员函数：常量成员函数
        * 表示this是一个指向常量对象的常量指针
        * 无论对象是否是const，都可以调用该常量成员函数
        * 不能改变调用该成员函数的对象的内容
    * **常量对象/指针/引用**只能调用常量成员函数，我们不能在常量对象上调用普通的成员函数，会把this指针指向一个常量对象，非法行为。

* 成员函数的内联属性
    * 内联声明
        * 隐式内联：类内定义的成员函数默认为内联函数
        * 显式内联：加inline关键字
            * 类内声明的时候加**inline**关键字进行显式声明
            * 类外定义函数的时候加**inline**关键字 进行显式声明
        * 可以在类外定义和类内声明同时说明inline
    * 内联定义的位置
        * 内联的成员函数和内联的普通函数应该和相应的类放在**同一个头文件**中
    * 内联的实际效果
        * 即使你声明了内联，最终是否内联取决于编译器的判断
* 成员函数的重载：
    * 成员函数可以被重载，只要参数数量和类型有区别
    * 成员函数的重载匹配和非成员函数重载匹配类似
    * 基于const的成员函数重载


#### 构造函数作为一种成员函数

构造函数
: 控制类对象的初始化过程，初始化对象的数据成员

* 构造函数执行：无论何时对象被创建，那么就会执行构造函数

* 类可以有不同的构造函数进行重载，不同构造函数参数数量和类型必须不同

* 构造函数特点
    * 没有返回值
    * 函数名和类名相同
    * 参数列表
    * 函数体

* Question:构造函数可以是const吗？this指针可以是const类型？
* Answer:不能！
    * 没有意义：
        * 构造函数用于构造类对象，不能被已经初始化的对象调用
        * const用于避免改变调用函数的对象的值，构造函数用于给对象数据成员赋初始值。

##### 默认构造函数

* 默认构造函数
    * 自定义默认构造函数：
        * 不需要任何实参
        * 或者为所有的参数提供了默认实参
    * 类内只能有一个默认构造函数
    * 产生条件：如果我们不显式定义构造函数，编译器会我们合成默认的构造函数--合成的默认构造函数
    * 作用：
        * 如果成员存在类内初始值，那么用它来初始化成员
        * 否则执行默认初始化该成员

* 合成的默认构造函数只适合简单类
* **某些类不能依靠合成的默认构造函数**
    1. 不要想着说我不写默认构造函数，编译器会帮我写。实际上是如果你定义了其他的构造函数，编译器不会帮你合成，这个时候你需要自己定义
    2. 合成的默认构造函数可能执行错误的操作
        * 内置类型如int或者复合类型数组和指针 在编译器的默认初始化下的值是未定义的，可能是随机值。
    3. 类A内的 类类型为B的成员 没有默认构造函数，编译器无法初始化该成员，因此无法合成默认构造函数。此时我们需要自己定义默认构造函数

* `=default` 的意义
    * 我们有其他的构造函数，这个时候编译器不会为我们合成默认构造函数
    * 但是我想要一个默认构造函数，并且它的功能编译器合成的功能一样
    * 同时我们不想去写，这个时候我们加上`=default`，让编译器帮我合成

* 自动执行默认构造函数的使用场景：
    * 对象被默认初始化自动执行默认构造函数
        * 类内含有类类型的成员，且使用合成的默认构造函数
        * 类内的类类型成员没有在构造函数初始值列表中显式初始化时，且没有类内初始值
        * 在块作用域外不使用初始值定义一个非静态变量/数组时
    * 值初始化时自动执行默认构造函数
        * 在数组初始化过程中提供的值数量小于数组长度
        * 静态局部变量没有显式初始化时执行值初始化
        * ~~书写形如T()显式请求值初始化~~

* 使用默认初始化： 
    1. `Sales_data obj;`正确
    2. `Box box = Box()`正确
    3. `Box box()`错误
    4. `Box *pbox = new box`正确


##### 构造函数初始值列表
* 构造函数初始值列表：冒号以及冒号和花括号之问的代码
    * 功能：为新创建的对象的数据成员赋初始值
    * 某个数据成员被构造函数初始值列表**忽略时**，该成员将在函数体之前执行默认初始化
        * 如果是类类型成员
            * 有类内初始值，进行初始化
            * 没有类内初始值，
                * 有默认构造函数，那么就执行默认初始化
                * 如果类类型成员没有默认构造函数，那么出错
        * 内置类型
            * 有类内初始值，使用类内初始值进行初始化
            * 没有类内初始值，执行默认初始化为未定义类型，出错了。
    * best practice:
        * 如果你的编译器不支持类内初始值，那么每个构造函数都应该显式初始化每个**内置类型**的类数据成员
            * 这个时候类的内置类型成员在块作用域内，如果没有类内初始值，也不显式初始化，那么它会成为未定义的值

* 构造函数初始值列表有时必不可少：如果没有类内初始值，必须通过构造函数初始值列表提供值进行初始化
    * 类内成员为const或者引用
    * 类类型成员并且没有默认构造函数的。

* 构造函数初始值列表的顺序并不影响初始化的顺序：成员初始化顺序和在类中出现的顺序对应

* 委托构造函数：
    * 初始值列表只有一个入口-类名本身
    * 紧跟括号代表的参数列表，参数列表必须和另外的构造函数匹配

### 定义类相关的非成员函数

* 这种与类相关的非成员函数概念上属于类的接口组成部分
* 定义类的非成员函数和定义其他函数一样，把函数的声明和定义分开来
* 类相关的非成员函数应该声明在类的头文件中，用户使用只需要引入头文件


### 定义类的数据成员
* 类的数据成员
    * 数据成员类型
        * 内置类型
        * 类类型
    * 数据成员类内初始值
        * =初始化
        * {}直接初始化

## 类的静态成员

* 静态成员声明：static关键字
    * 可以是private/public/protect
    * 可以是常量/引用/指针/类类型
    * 静态类别
        * 静态数据成员
        * 静态成员函数

* 静态成员定义
    * 静态成员函数
        * 可以定义在类内，也可以定义在类外部（此时不用加static关键字）
    * 静态数据成员
        * 必须在类外定义和初始化静态数据成员
            * 类型名+类名+作用域运算符+成员名字
            * 在类的作用域中，可以调用类的私有函数
            * 不用加static关键字
        * 只能定义一次：把静态数据成员的定义和其他非内联函数放在同一个源文件中
        * 存在程序的整个生命周期

* 静态成员的类内初始化（例外情况）
    * 要求：
        * 要求静态成员是字面值常量类型的constexpr
        * 初始值必须是常量表达式。
    * 使用：
        * 用于常量表达式的地方
    * best practice:即使在类内为常量静态成员初始化提供了初始值，也应该在类外进行定义，但是不能再给予初始值. e.g. `constexpre in Account::peroid;`
* 静态成员的使用
    * 类名+作用域运算符直接访问
    * 类对象/指针/引用范围

* 静态成员的特殊使用场景
    * 可以是不完全类型，静态数据类型的类可以是它属于的类
    ```C++
    class Bar {
    public:
    private:
        static Bar mem1; // 正确，静态类型可以是不完全类型 
        Bar *mem2; // 正确，指针类型/引用类型可以是不完全类型 
        Bar mem3; // 错误，数据成员必须是完全类型
    };
    ```
    * 使用静态成员作为函数的默认实参
    ```C++
    class Screen {
    public:   
        Screen& clear(char = bkground);//非静态数据成员不能作为实参，因为它们属于对象的一部分
    private:
        static const char bkground;
    };
    ```
## 类的作用域

* 类定义的编译过程
    * 首先：编译成员的声明
        * 数据成员的声明
        * 成员函数名的声明：包括函数名/返回类型/参数类型
    * 其次：类全部可见才编译函数体
        * 函数体内的名字查找
* 名字的查找
    * 类成员声明（数据成员名和函数成员名）的名字查找
        1. 在块内当前位置的之前查找声明语句
        2. 在块内没有找到，查找外层作用域
        3. 外层作用域没有找到，报错
    * 类成员函数内的名字查找
        1. 函数内查找，在当前位置之前的范围查找
        2. 在类内查找：包括当前位置之后所有范围内的名字
        3. 类内没找到，在外层作用域中当前成员函数定义之前的作用域中查找
        4. 外层作用域没找到，报错



## 访问控制：
* Question1：访问控制的作用
* Answer1:加强类的封装性

* Question2:封装的优点是什么吗？
    * 确保用户代码不会无意间破坏封装对象
        * private数据成员用户不可以访问，public却可以
    * 被封装类的细节可以随时改变，无需调整用户级别代码
        * 假如用户使用了public数据成员，那么即使是改变该public数据成员变量名字，所有的用户代码都必须修改。
    * 方便调试错误和定位缺陷
        * 如果有程序破坏了对象的状态，那么只有实现类部分的代码才有可能，而非用户代码区，这样能够快速定位错误范围。



### 访问控制说明符：
* 访问控制说明符：访问说明符指定接下来成员的访问级别
    * 一个类可以包含0个或多个
    * 同一种访问说明符可以出现多次
    * 有效范围到下一个访问说明符出现或者类结束
    * 如果没有指定访问说明符，则为默认访问说明符。
        * 取决于定义类的关键字
            * class：默认为private
            * struct：默认为public

 * 访问控制说明符分类：
    * public：整个程序都可以访问
    * private：被类的成员函数访问，不能被使用该类的代码访问
    * [protected:]()
        * 对类的用户不可访问
        * 对派生类的成员和友元:只能通过派生类对象来访问，不能通过基类对象访问

### 给予特殊访问控制权：友元

定义：类允许其他类或者其他函数访问它的非公有成员，方法是把类或者函数作为类的友元
* 它不受访问控制符约束
* 友元不是类的成员

* 友元的声明
    * 友元声明是声明了友元的访问权限，而非普通意义上的函数声明：并不是声明函数的存在
    * 如果我们希望在用户代码使用友元函数，必须在类外再次声明
    ```C++
    struct X{
        friend void f(){} // 即使定义在类内，也必须在类外进行声明
        X(){ f(); } // 错误，类还没声明
        void g();
        void h();
    };
    void X::g(){ return f(); } // 错误 f()在类外还没有声明
    void f(); // 类外声明f()
    void X::h(){ return f(); } // 正确 f()在类外被声明了
    ```
    * best pactice：
        * 最好在类定义开始或者结束的位置做友元的类内声明
        * 通常将友元的类外声明和类的头文件放在一起

* 普通函数作为友元
    * 函数重载的情况：尽管函数名字相同，但是仍然是不同的函数
        * 单个函数作为友元，不代表它的重载函数具有类的访问权限
        * 如果想把一组重载函数声明友元，需要对这一组函数进行友元声明
* [A类作为B类的友元](../代码/chapter7/friend_class.cpp)
    * B类中必须包含类A的友元声明
* [类的成员函数作为友元](../代码/chapter7/friend_member_function.cpp)：必须仔细组织程序结构，满足声明和定义的依赖关系 e.g. [Sniper](../代码/chapter7/Sniper.cpp)


## 类的其他特性
* 类的类型成员：
    * 定义：可以定义某种类型在类内的别名
    * 访问限制：存在public/private
    * 定义方式：
        * typedef:`typedef string::size_type pos`
        * using:`using pos = string::size_type`
    * 类型成员必须先定义，后使用。因此它应该出现在类的开头的地方

* 类的可变数据成员：mutable关键字
    * 定义：希望能够修改类的数据成员，即使是在const函数内
    * 可变数据成员mutable永远不会是const
