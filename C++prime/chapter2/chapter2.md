# 变量和基本类型
> 字节定义
> : 计算机中可寻址的最小内存块。通常计算机的字节为8bit。      

> 字的定义
> : 计算机中储存的基本单位是字。通常为计算机的一个字为32bit/64bit，对应为4字节/8字节


> 为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。如知道位置736424处为float类型
> * 类型决定从该地址开始占用的比特数。从位置736424开始的32个bit表示float内容。因为标准规定float类型占32个bit。
> * 类型决定了如何解释这些比特的内容。float变量实际存储的值依赖于该机器是如何存储浮点数的。
## 基本内置类型

### 算术类型

* 整型
    * 整数型
        * (unsigned)short 标准规定最小16bit 实际编译器规定为16bit
        * (unsigned)int 标准规定最小16bit 实际编译器规定为32bit
        * (unsigned)long 标准规定最小32bit 实际编译器规定为32bit
        * (unsigned)long long 标准规定最小64bit 实际编译器规定为64bit
    * 字符型
        * char:最少8bit，存放机器基本字符集
            * unsigned char
            * signed char
            * char
        >  字符型实际表示形式只有2种，无符号和有符号。char的具体表示类型由编译器决定。表现为以上二者之一：在一些机器上char类型为unsigned char,在其他机器上可能表现为signed char
        * wchar_t：最少16bit，存放机器最大扩展字符集
        * char16_t：最少16bit，为Unicode字符集服务，所有自然语言的标准
        * char32_t：最少32bit，为Unicode字符集服务，所有自然语言的标准
    * 布尔型：true/false
* 浮点型：C++标准规定了浮点数的有效位数的最小值，然后大多数编译器实现了更高的精度
    * float：占用32个bit，标准规定最少有效位是6位，实际一般编译器实现了7个有效位
    * double：占用64个bit，标准规定最少有效位是10位，实际一般编译器实现了16个有效位
    * long double:  ~~被用于有特殊浮点数需求的硬件~~

* **选择数据类型的几点经验**
    1. 明知道数值不为负数，选无符号类型
    2. 通常情况下用int执行整数运算。short太小，long一般和int大小相同
    3. 数值范围超过了int表示，则选用long long表示
    4. 算术表达式不要用bool或者char类型表示整数。
        * 因为你不知道机器上的char属于unsigned还是signed
        * bool在算术表达式中非0即1
    5. 如果需要使用一个不大的整数。可以明确指明类型为unsigned char或者signed char
    6. 浮点数计算优先使用double
        * float精度比double小
        * double计算代价稍微大，但是相差无几（计算量大的运算还是要考虑计算代价）
    7. long double提供的精度一般情况下用不到，并且运行时消耗比较大，不可忽略。

### 类型转换

* 转换规则
    1. 非bool->bool类型：初始值为0则结果为false，否则结果为true
    2. bool->非bool：初始值为false结果为0，初始值为true结果为1
    3. 浮点数->整数：进行近似处理
    4. 整数->浮点数：小数部分记为0
    5. 无符号->有符号类型 `unsigned char c = -1` 结果c为255
    6. 有符号->无符号类型 `signed char c1 = 256` 结果未定义

* 转换场景
    * 一种类型赋值给另外一种类型的变量 `bool b = 42;`
    * 某处使用某种类型，实际需要另外一种类型。如if条件语句
    ```C++
    int i = 42;
    if(i)
        i = 0;
    ```
    * 表达式自动转换 
    ```C++
    unsigned u  = 10;
    int i = -42;
    std::cout << u + i << std::endl;
    ```
    > 表达式里面同时出现符号类型和无符号类型，带符号类型自动转换成无符号类型。



### 字面值常量
> * 字面值的形式和值大小决定了字面值具体的数据类型
> * 如果指定字面值的类型，字面值有默认的数据类型
> * 我们可以通过指定前缀和后缀改变字面值的默认数据类型

* 整型字面值
    * 形式
        * 20 十进制
        * 024 八进制
        * 0x14 十六进制
    * 类别判断
        * 十进制
            * 默认是有符号数
            * 默认取int/long/long long中尺寸最小的，前提是可以容纳当前的值
        * 八进制/十六进制
            * 默认取int/unsigned int/long/unsigned long/long long/unsigned long long 前提是能过容纳当前的值
    * 没有整型字面值的数据类型会是short：
        * `short s = 2;`要进行类型转换
        * 2的字面值类型是int，而s变量类型为short
* 浮点数字面值
    * 形式
        * 3.1415926
        * 3.14E0
        * 0e0
        * .001
    * 浮点数字面值默认数据类型为double
* 字符字面值 ` 'a' ` 字面值类型默认是char类型
* 字符串字面值 ` "abcdefg" `
> 1. 实际上常量字符构成的数组，结尾处添加空字符'\0'，实际长度比它的内容多1
> 2. 两个字符串字面值位置紧邻，且仅仅由空格、锁进、换行符分割，则它们实际上是一个整体
```C++
std::cout << "a really, really long string literal "
"that spans two lines" << std::endl;
```
* 转义字符序列
    * 不可打印字符，无法显示出来
        * 换行\n
        * 制表符\t
    * 在C++中有特殊语义，如果不转义会起冲突。
        * \" 双引号在C++中字符串字面值中
        * \' 单引号用在字符中
        * \\ 斜杠
    * 泛化的转义字符序列:数字部分对应字符的数值
        * \x+十六进制数：\x4d->'M'
        * \ +八进制数： \115->'M' \0->null
    > 不仅仅可以表示**不可打印字符**和**已在C++中存在的特殊语义字符**，还可以表示普通的字符。


* 指定字面值类型
    * 前缀-用于指定字符和字符串字面值
        * u char16_t
        * U char32_t
        * L wchar_t
        * u8 char
    * 后缀-指定算术类型
        * u/U unsigned
        * l/L long
        * ll/LL long long
        * f/F Float
        * l/L long double

* 布尔字面值 ture/false
* 指针字面值 nullptr


## 变量

### 变量的定义

* 变量定义：类型说明符，紧跟一个多个变量名组成的列表，变量名以逗号隔开，最后以分号结束

* 初始化和赋值区别：   
    * 初始化：创建变量赋予一个初始值
    * 赋值：擦去旧的值，用新的值代替

* 显示初始化：创建时获得了特定的值
    * 拷贝初始化：编译器把等号右边的初始值拷贝到新建的对象中
    * 直接初始化：不使用等号

* 涉及容器元素序列（vector对象）的初始化：即不仅仅包含一个值，多个值序列。
    * 值初始化：只提供容器容纳的数量而不提供初始值，这个时候库会创建值初始化的初值，赋予容器中的元素
        * 属于直接初始化，不能用等号
        * 取决于元素的类型
            * 内置类型：自动设为0
            * 类类型：默认初始化的值。
        * **此时如果类不支持默认初始化，则无法值初始化**
        * 只提供数量不提供初始值，则只能使用直接初始化的方式，因此不能有等号
    * 列表初始化：
        * 既可以使用等号，也可以不使用等号
        * 既可以用来初始化，也可以用来赋值
        * 当用于内置类型并且有丢失信息的风险，编译器会报错
        ```C++
        long double  ld = 3.1415926;
        int a{ld},b = {ld};// 编译器报错
        ```
        * 和圆括号区别：
            * 圆括号优先构造初始化
            * 花括号优先列表初始化，如果实在无法列表初始化（列表内元素类型不同）则尝试使用列表构造对象

* 默认初始化：未显示初始化，创建时不提供初始值
如果定义变量时，没有指定初值，那么变量被默认初始化，变量被赋予默认值
* 默认值取决于变量类型和定义变量的位置
    * 内置类型
        * 定义于任何函数之外的话：初始化为0
        * 定义在函数体内的变量将**不被初始化**，此时值是未定义的
    * 类类型：自己决定初始化对象的方式
        * 大多数支持无须显式初始化定义对象，为其提供默认值 e.g. `string empty;`
        * 少数类要求必须显式初始化，否则引发错误



### 变量声明和定义的关系

* Question：变量的声明和定义明明差不多，为什么要区分开来？？
* Answer：C++采用分离式编译，源文件可以分在多个cpp文件中。文件间需要共享代码，如果想使用定义在其他文件的变量，必须事先包含那个变量的声明，而不可能重新定义一个相同的变量。所以才区分声明和定义

* 声明和定义的区别；
    * 声明：
        * 规定了类型和变量名
        * 如果该变量被定义在外面的文件，加关键字extern
        * 可以被多次声明
    * 定义：
        * 也规定了类型和变量名
        * 申请内存空间
        * 给变量赋初始值

## 复合类型

* 通用的声明语句
    * 基本数据类型
    * 声明符列表
        * 变量名
        * 引用符号&
        * 指针符号*

* 引用：
    * 引用的定义
        * 一条语句可以定义多个引用，引用标识符&开始
        * 引用定义时必须初始化
        * 引用的绑定与对象必须严格匹配（除了2种例外情况）
            1. 初始化常量引用可以使用任意表达式:编译器用一个临时空间暂存表达式的计算结果临时创建的临时对象
                * `int i = 42;const int &r1 = i;`
                * `const int &r2 = 42;`
                * `const int &r3 = r2 * 32;`
    * 引用即别名：引用不是对象，是为它绑定对象的别名
        * 用引用赋值：使用引用绑定的对象的值来赋值
        * 为引用赋值：给引用绑定的对象赋值
        * 获取引用值：获取引用绑定对象的值
        * 使用引用A绑定引用B：将引用A绑定到引用B绑定到对象上

* 指针
    * 指针的类型要和它指向的对象类型严格匹配（除了2种例外情况）
        1. 允许一个指向常量的指针指向非常量对象
            * `double dval = 3.14;const double *cptr = &dval;`
    * 指针的值
        * 指向一个对象
        * 空指针:没有指向任何对象，无法访问
        * 无效指针：指针变量值地址随机，访问引发错误
        * 指向紧邻对象的下一个位置地址：不指向具体对象，无法访问
    * 使用指针
        * 获取指针：`int val = 42; int *p = &val;`
        * 利用指针访问对象：`*p = 100; cout << *p;`
        * 指针作为条件语句：`if(p)`
    * &和*既能作为声明符又能作为表达式运算符
    * void*指针：保存任何对象的地址

* 指针和引用区别

| 指针 | 引用 | 
| :-----:| :----: | 
| 指针是实体对象 | 不是实体对象只是别名| 
| 因为是实体，所以需要分配内存 | 不需要分配内存，绑定对象的内存| 
| 无需初始化 | 必须初始化绑定 | 
| 可以改变值|不可修改绑定的对象 | 
| 值可以为空| 不可以为空|
| 存在指针的指针 | 不存在引用的引用| 
| 存在对指针的引用 | 不存在引用的指针| 
| sizeof是指针变量的大小 | sizeof是引用绑定对象的大小| 


* 理解复合类型的声明
    * 声明符*和&跟随变量名，基本数据类型不变`int i = 1024,*p = &i,&r = i;`
    * 复合类型：从右往左阅读r的定义，离变量名最近的符号对变量的类型有最直接的影响
        * 指针的指针 `int i = 1024;int *pi = &i;int **ppi = &pi;`
        * 指针的引用 `int i = 24; int *p = &i; int *&r = p;`
            * 从右往左离r最近的是&，r是一个引用
            * 其余部分确定r的引用对象类型 *说明引用的是一个指针，指针指向int
        * 引用的指针 ：引用不是对象 `int &*p` 不能使用指向引用的指针


* const属性
    * 特点：只可以读，不可以写
    * 必须初始化
        * 运行时初始化：`const int i = get_size()`
        * 编译时初始化：`const int bufSize = 512;`
            * 独享式const
                * 编译时执行变量替换：把bufSize的地方用512替代
                * 编译时对单个源文件进行编译，编译时每个使用了const对象的文件必须能够访问它的初始值，因此每个用它的文件必须包含该const对象的定义
                * 默认情况下，const对象被设定仅在当前文件有效。如果多个文件出现了同名的const变量，则认为它们是独立的变量
            * 共享式const：一个文件定义，多个文件声明并且使用它。
                * `extern const int bufSize = fcn(); // file1.cc` 
                    * 定义并初始化了bufSize
                    * bufSize是一个常量，为了该定义可以被其他文件使用，加extern限定符
                * `extern const int bufSize; // file1.h`指明了bufSize是在其他文件中定义
    * const和引用
        * 常量引用: 
            * 正确理解：对const对象的引用简称 `const in ci =10; const int &r = ci;`
            * 错误理解：引用是一个常量。更正：实际上引用不是对象，无法用const修饰。但是引用无法解绑定，从这种意义上它又是const
    * const和指针
        * 指向常量对象的非常量指针`const int i = 100; const int *p1 = &i;`
        * 指向常量对象的常量指针 `const int i = 100; const int *const p2 = &i;`
    * const顶层和底层属性
        * 顶层：任意的常量对象
            * 执行拷贝操作不影响被拷贝对象的值，
        * 底层：和指针引用复合类型相关，指向的对象是一个常量
            * 拷贝操作：
                * 拷入和拷出对象必须具备相同的底层
                    * `const int ci =42;`
                    * `const int *p2 = &ci;`
                    * `const int *const p3 = p2`;
                    * `p2 = p3;`
                * 两个数据对象类型可以转换
                    * `int i = 100;`
                    * `p2 = &i;`
                
    
* 常量表达式：编译的时候就确定结果并且运行时值不改变的表达式
    * 种类
        * 字面值：3/'a'/"nihao"
        * 常量表达式初始化的const对象： `const int max_file = 20;`


* constexpr变量：C++11新特性
    * 概念
        * 声明constexpr的变量是一个常量，并且必须初始化。
        * 初始化使用常量表达式，不是常量表达式会出错
        * 编译器看到关键字constexpr会去验证变量的初始值是否是一个常量表达式,如果不是会出错。
    * 定义：
        * 初始值
            * 初始值为字面值 `constexpr int mf = 20;`
            * 初始值为常量表达式`constexpr int limit = mf + 1;`
            * 初始值为函数 `const int sz = size(i);`
                * size(int i)是普通函数时出错:即使size(i)返回常量表达式还是会错误
                * size(int i)是constexpr函数时，会去检查size(int i)是否返回了常量表达式
                    * `constexpr int i = size(2); // size(2)返回了常量表达式`编译器检查语法正确
                    * `int a = 2; constexpr int j = size(a); // size(a)返回非常量表达式` 编译器检查语法错误
            ```C++ 
            constexpr int size(int i)
            {
                return i;
            }
            ```
        * 类型：constexpr关键字适用的类型只能是字面值类型
            * 包括
                * 算术类型
                * 引用类型/指针类型：
                    * 初始值受限制
                        * 初始值必须是nullptr/0
                        * 初始值必须是某个固定地址的对象：
                            * 所以函数体外的对象
                            * 函数内的static变量
                    * constexpr关键字仅仅和指针有关,并且把指针置于顶层
                    ```C++
                    const int *p = nullptr; // 指向整型常量的指针
                    constexpr int * q = nullptr; // 指向整型的常量指针 相当于 int * const q; q是一个顶层cosnt
                    ```
                * 数据成员都是字面值类型的聚合类
                * ~~待补充~~

* constexpr函数：一般用于足够简单编译时就能确定结果
    * 格式要求
        * 只有一条返回语句
        * 所有形参都是字面值类型
        * 返回类型也是字面值类型
        * 可以包含空语句/类型别名/using
    * 使用constexpr初始化constexpr变量时，编译器把对其的调用替换成结果值--》constexpr函数是隐式内联函数
    * constexpr函数不一定返回常量表达式
    * 必须在头文件中
        * constexpr函数需要使用定义进行函数展开
        * 如果需要多次使用该函数的话，必须放在头文件中来引入，保持所有定义一致。


## 对类型和复合类型的处理

### 给类型设置类型别名
1. `typedef double wages;`
2. `using SI = Sales_item;`


### auto 类型说明符 C++11新特性
auto类型说明符：用它就能让编译器替我们去分析表达式所属的类型
* 一条语句可以声明多个变量，但是变量的基本数据类型必须相同
```C++
auto i= 0, *p= &i; // 正确 基础数据类型都是int
auto sz = 0, pi = 3. 14;// 错误 pi推倒得到double，而sz推导得到int
```
* 编译器以引用对象的类型作为auto类型值，要想得到引用类型，得加上&，但是此时初始值的顶层const属性被保留推导出来
```C++
int i = 0;
int &r = i;
auto a = r;//a为int类型
const auto &j = 42;// auto推导得到int，j为const int的引用，可以为常量引用绑定字面值

const int ci = i;
auto &g = ci; // g为const int引用，ci的顶层const被保留

```
* 编译器会忽略顶层const，如果想要推断出来的类型是const顶层，需要明确指明
`int i =0; const int ci = i;const auto f = ci;// ci推演出来是int，而f是const int`

* 编译器会保留底层const
`int i = 0; const int ci = i;auto e = &ci; // &ci是一个指向整型常量的指针，是一个底层const属性，推导e是一个指向const int的指针`
### decltype 类型指示符

decltype:返回表达式的类型，但是并不计算表达式的结果，因为它不会用这个结果来初始化，它只需要知道结果类型。

* 如实保留顶层const
```C++
const int ci = 0;
decltype(ci) x = 0;// x的类型是const int
```
* 如实保留引用属性，而不是转而从引用绑定的对象推断
```C++
const int ci = 0;
const int &cj = ci;
decltype(cj) y = x;// y的类型是const int&
```

* 如果是表达式，则根据表达式结果推断
```C++
int i = 0;
int *p = &i;
int &r = i;
decltype(r) k = i; // r为引用，推断得到k为int &类型，绑定到i上
decltype( r + 0) j = 0; // r + 0 表达式结果为int，得到j为int类型，初始值为0
decltype(*p) q = i; // *p解引用运算符返回一个左值引用，因为可以赋值*p = 2. 所以推断q的类型为int&并且绑定到i
```
* 表达式是变量被加上括号，永远都是得到引用类型
```C++
int i = 0;
decltype((i)) d = i; // (i)是个表达式，返回的变量是一个左值，因此推断d为int引用，绑定到i
```