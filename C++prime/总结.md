7. 构造函数问题
    * 构造函数定义
        * 名字与类相同
        * 不过没有返回类型
        * 有参数类型和函数体

    * 构造函数不能是const，也没有必要是const
        * 没有const的构造函数也能初始化const对象,和其他成员函数不同
        * 先有对象初始化再有const属性：通过构造函数初始化对象后，对象然后获得const属性
        * 假设先有const属性而对象不可改变值，那么构造函数如何给对象初始化？
    * 默认构造函数
        * 无需实参
        * 控制默认初始化过程
            * 类内有初始值，用来初始化成员
            * 类内没有初始值，默认初始化成员
                * 什么是默认初始化？
                    * 定义变量时没有初值，变量赋予默认值
                    * 默认值取决于变量的类型和变量的位置
                        * 内置类型
                            * 在函数体外部的变量默认初始化为0
                            * 在函数体内部的局部变量默认时未定义的，试图拷贝或者访问将发生错误
                        * 类类型
                            * 绝大多数类支持无需显示初始化，提供一个默认的初始值如string类
                            * 某些类没提供默认值，要求必须显示初始化，否则是未定义的
        * 如果我们没有定义任何构造函数，编译器将为类创造合成的默认构造函数，适合简单的类。
        * 一般的类必须定义自己的默认构造函数（包含内置类型或者复合类型-数组和指针）
            * 如果自己定义了其他的构造函数，编译器不会为我们合成默认构造函数，这个时候我们就没有默认构造函数了
            * 合成的默认构造函数可能出错：在函数内用合成的默认构造函数初始化一个对象，该对象包含内置类型，此时这些内置类型默认初始化为未定义，导致出错。因此对于包含内置类型的类，该类要么类内初始化，要么定义自己的默认构造函数
            * 类中包含其他的类成员，且这类成员所在类没有默认构造函数，编译器无法合成默认构造函数
        * =default含义
            * 我们继续用其他构造函数，也需要默认构造函数
            * 通过这个要求编译器帮忙合成默认的构造函数
    * 构造函数
        * 构造函数初始值列表
            * 显式初始化成员
            * 否则对成员执行默认初始化
        * 构造函数初始值有时必不可少
            * 成员是const，必须初始化
            * 成员是引用，必须在初始化时绑定
        * 默认实参
            * 构造函数如果为所有参数提供了实参，那么它就是实际意义上的默认构造函数
    * 委托构造函数：把自己的职责委托给其他构造函数

8. 内联函数
    * 内联函数可以在程序中被多次定义
    * 内联函数通常定义在头文件中，通常在调用点内联地展开
    * 通常用于规模小、流程直接、频繁调用的函数用来避免函数调用的时空开销。
8. 初始化和赋值
    * 初始化：创建变量是赋予一个初始值
    * 赋值：变量已经存在，擦去旧值，赋予新值
9. explicit 关键字：禁止隐式转换
    * 抑制构造函数定义的隐式转化
    * 只对含有一个参数的构造函数有效：因为多个参数无法执行隐式转换，因此没有必要。
    * 只在类内声明构造函数时指定explicit，类外定义指定explicit是不可以的
    * 隐式转换可能发生在拷贝初始化，带explicit关键字不可以拷贝=，只能直接初始化使用
    * 但是可以static_cast进行显示转换
9. 常量表达式概念：
    * 值一定不会改变
    * 编译的时候就能得到结果
10. constexpr：由编译器来验证变量的值是否是常量表达式
    * 声明constexpr的变量是常量，必须用常量表达式初始化
    * 用来声明constexpr的类型是字面值类型：算术类型/指针/引用
    * 与指针关系
        * 只对指针有效，与指针的对象无关
        * constexpr指针既可以指向常量，也可以指向非常量
        * constexpr指针只能绑定到全局变量和static静态局部变量上（固定地址）
11. constexpr函数：常能用于常量表达式的函数
    * 函数的返回类型和形参必须都是字面值类型：算术/指针/引用
    * 有且只有一条return语句：如果有多条return可能涉及到函数的运行，内部进行逻辑判断等，不符合常量表达式定义
    * 用constexpr函数执行常量表达式初始化时：constexpr int foo=new_sz()
        * 编译器将函数调用替换成其结果字面值
        * constexpr被隐式指定为内联函数
    * constexpr函数不一定返回常量表达式
    * 编译器负责检查constexpr函数结果是否符合要求，不符合发出错误信息
    * 通常定义在头文件中，类似内联函数
12. 类的静态成员
    * 类的静态成员存在于任何对象之外，对象不包含其数据
        * 静态数据成员
            * 任何类对象不包含静态数据成员
            * 没有构造函数初始化
            * 在类的外部定义和初始化
            * 在类的里面使用static声明
            * 存在于整个程序声明周期
            * 和非内联的类成员函数一起在源文件中，避免多次定义
        * 静态成员函数
            * 不和任何对象绑定
            * 没有this指针，因此也没有修饰this的const。即函数不是常量
            * 可以在外部定义，但是关键字static只出现在类内部声明处
            * 可以定义在类内部，也可以定义在类外部
    * 使用：
        * 作用域运算符直接访问静态成员
        * 通过对象、引用、指针访问
        * 成员函数使用静态成员（数据成员/函数）不需要作用域运算符，直接使用
    * 例外：
        1. 字面值常量类型的constexpr静态类型可以在类内初始化
            * 初始值必须是常量表达式
            * 通常也应该在类的外面定义一下：不带初始值的静态成员定义
        2. 静态数据成员可以是不完全类型--是它所属的类类型
        3. 可以做默认实参
* decltype: 希望从表达式推出定义变量的类型，但是不想用该表达式初始化，结果和表达式的形式密切相关
    * 如果表达式是个变量：返回变量类型（包括const和引用）
    * 如果表达式不是一个变量：
        * 返回表达式结果对应的类型 
        * 如果表达式是个左值，那么一定是个引用：int *p,decltype(*p) 结果类型是int&
* auto：编译器通过初始值判断变量的类型
    * 编译器会适当改变结果类型符合初始化规则
        * auto以引用对象的类型作为变量类型
        * auto一般忽略顶层const，而保留顶层const
        * 希望推断出来const，需要明确声明const
    * auto 引用类型使用原来的初始化规则：顶层const得到保留

* 表达式：左值和右值（一般来说，左值可以位于等号左边，而右值不可以）
    * 右值：
        * 当一个对象被用做右值时，使用的是它的值
        * 比较短暂，要么是字面值常量，要么是临时变量
    * 左值：
        * 当一个对象被用做左值时，使用的是它的身份（内存中的位置）
        * 一般有比较持久的状态，如变量
    * 需要右值的地方可以用左值，不能把右值当成左值
* 右值引用
    * 必须绑定到右值的引用&&，不能绑定到左值
    * 只能绑定到一个即将销毁的对象
    * 只能绑定到表达式、字面值、和返回右值的表达式
    * 右值引用无法绑定到右值引用变量
* 左值引用
    * 也叫常规引用，必须绑定到左值
    * const左值引用可以绑定到右值，因为中间隐式生成临时变量
    * 不能绑定到要求转化到表达式、字面值、和返回右值的表达式
    * 左值引用可以绑定到左值引用变量

* 拷贝控制操作
    * 拷贝构造函数(用于定义初始化)
        * 第一个参数是引用类型
        * 任何额外参数有默认值
        * 如果我们没有定义，编译器会和成员一个拷贝构造函数
        * 即使定义了其他构造函数，编译器也会合成一个拷贝构造函数
    * 拷贝赋值运算符（用于定义后的再复制）
        * 如果类没有定义拷贝赋值运算符，那么编译器会合成一个拷贝赋值
        * 为了与内置类型保持一致，通常返回一个指向左侧运算对象的引用，可以a=b=c;
        * 
    * 移动构造函数
    * 移动赋值运算符
    * 析构函数
        * 由波浪号和类名
        * 没有返回值和参数->不能重载
        * 给定一个类只有一个析构函数
        * 先执行函数体，然后按初始化逆序销毁
        * 释放对象在生存期分配的所有资源
        * 使用场景
            * 局部变量离开作用域
            * 对象被销毁，其成员被销毁
            * 容器被销毁时，其元素被销毁
            * 临时对象创建它的表达式结束会销毁
        * 当一个对象的引用或者指针离开作用域，不会执行析构函数
* 三五法则：
    * 如果一个类需要自定义析构函数，那么它也需要定义拷贝构造和拷贝赋值
    * 如果需要一个自定义拷贝构造函数，那么肯定需要拷贝赋值运算符
    * 如果一个类需要自定义拷贝赋值，那么肯定需要它需要拷贝构造函数
    * 无论是拷贝构造还是拷贝赋值，都不意味着需要析构函数

* 拷贝初始化和直接初始化
    * 拷贝初始化：编译器将右侧对象的值拷贝到左侧正在创建的对象
        * 依靠拷贝构造函数和移动构造函数
        * 使用场景：
            * 使用=定义对象
            * 将对象作为实参传递给一个非引用类型的形参
            * 从一个非引用类型返回对象
            * 花括号列表初始化一个数组或者聚合类型的数据成员
            * 初始化标准库容器或者调用insert和push e.g.vector<int>v; v.insert(1);
    * 直接初始化：编译器使用函数匹配来选择和我们参数最匹配的构造函数
* =default 和 =delete
    * 可以对任何函数使用=delete,但是只能对拷贝控制成员和默认构造函数使用=default
    * =delete必须在i第一次声明时候使用，而=default 可以在类外定义的时候使用
    * 析构函数不能被=delete,是则无法定义对象
* 阻止拷贝：
    * 新标准下：使用=delete
    * 旧标准下：将拷贝操作声明为private但是不定义

* 运算符重载
    * 由operator和后面的符号决定
    * 形式和其他函数一样
    * 类的成员运算符函数要比普通运算符函数少一个参数
    * 它或者是类的成员或者至少有一个类类型参数
    * 其无法作用取代内置类型的运算对象
    * 优先级和结合律与内置运算符保持一致
* 某些运算符不应该也不建议被重载
    * 无法保留求值顺序
    * 无法保留短路求值属性
    * .和&运算符已经被用于类类型的对象，有了内置的定义


